<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Pro Kalibrierung: A4 + Würfel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()"></script>
    <style>
        body { margin:0; background:#050505; color:white; overflow:hidden; font-family: 'Inter', sans-serif; }
        video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
        .panel { 
            position:absolute; bottom:20px; left:20px; right:20px; 
            background:rgba(20,20,20,0.95); padding:20px; border-radius:16px; 
            border: 1px solid rgba(255,255,255,0.1); z-index:10; max-width: 500px; margin: 0 auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        button { 
            width:100%; padding:14px; border-radius:10px; border:none; font-weight:bold; margin-top:10px; font-size:14px;
            transition: all 0.2s;
        }
        button:active { transform: scale(0.98); }
        .btn-primary { background: #FFD700; color:black; }
        .btn-secondary { background: #333; color: white; border: 1px solid #555; }
        .btn-calc { background: #2563EB; color: white; }
        
        /* Grid Overlay */
        .grid-overlay {
            position: absolute; inset:0; pointer-events: none; opacity: 0.1;
            background-image: linear-gradient(#fff 1px, transparent 1px), linear-gradient(90deg, #fff 1px, transparent 1px);
            background-size: 50px 50px;
        }
    </style>
</head>
<body>

<video id="video" playsinline muted style="display:none"></video>
<canvas id="canvas"></canvas>
<div class="grid-overlay"></div>

<div class="panel">
    <div class="flex justify-between items-center mb-2">
        <h2 class="font-bold text-lg">Scanner Kalibrierung</h2>
        <div id="status-badge" class="bg-gray-800 text-xs px-2 py-1 rounded text-gray-300">Lade...</div>
    </div>

    <!-- Info Bereich -->
    <div class="bg-gray-800 rounded p-2 text-xs mb-3 flex justify-between items-center">
        <span>Fotos: <span id="count" class="text-yellow-400 font-bold text-sm">0</span> / 6</span>
        <span id="rms-display" class="font-mono">RMS: --</span>
    </div>
    
    <!-- Farb-Slider -->
    <div class="mb-3">
        <div class="flex justify-between text-[10px] text-gray-400 mb-1">
            <span>Würfel Farbe (Hue) anpassen</span>
            <span id="hue-val">25</span>
        </div>
        <input type="range" min="0" max="60" value="25" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer" oninput="updateHue(this.value)">
    </div>

    <!-- Buttons -->
    <div id="controls">
        <button id="btn-action" class="btn-primary" onclick="startCamera()" disabled>Kamera starten</button>
        <button id="btn-calc" class="btn-calc hidden" onclick="runCalibration()">Jetzt Berechnen</button>
        <button id="btn-reset" class="btn-secondary hidden mt-2" onclick="resetData()">Neustart</button>
    </div>
    
    <div class="text-[10px] text-gray-500 mt-3 text-center">
        1. DIN A4 Blatt auf Tisch<br>
        2. Gelben Würfel (44mm) exakt in die Mitte
    </div>
</div>

<script>
// --- KONFIGURATION ---
const A4_W = 210; // mm
const A4_H = 297; // mm
const CUBE_H = 44; // mm
const MIN_IMGS = 6;

// Die 3D Welt-Koordinaten (werden später in OpenCV Mat gewandelt)
// Reihenfolge: TL, TR, BR, BL (Papier), Center (Würfel Top)
const WORLD_COORDS = [
    0, 0, 0,                // TL
    A4_W, 0, 0,             // TR
    A4_W, A4_H, 0,          // BR
    0, A4_H, 0,             // BL
    A4_W/2, A4_H/2, -CUBE_H // Würfel Oben (Negative Z-Achse in OpenCV Konvention oft besser)
];

// --- STATE ---
let video, canvas, ctx;
let streaming = false;
let capturedPoints = []; // JS Array mit den Punkt-Sets
let currentFramePoints = null; // Aktuell erkannte Punkte
let yellowHue = 25;

function onOpenCvReady() {
    updateStatus("Bereit", "green");
    document.getElementById("btn-action").disabled = false;
}

function updateHue(val) {
    yellowHue = parseInt(val);
    document.getElementById("hue-val").innerText = val;
}

function updateStatus(text, color="gray") {
    const el = document.getElementById("status-badge");
    el.innerText = text;
    el.className = `text-xs px-2 py-1 rounded text-white bg-${color}-600`;
}

async function startCamera() {
    video = document.getElementById("video");
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d", { willReadFrequently: true });

    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } }
        });
        video.srcObject = stream;
        await video.play();
        
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        streaming = true;
        
        // UI Umstellen
        const btn = document.getElementById("btn-action");
        btn.innerText = "Foto aufnehmen";
        btn.onclick = captureFrame;
        document.getElementById("btn-reset").classList.remove("hidden");
        
        requestAnimationFrame(processLoop);
        
    } catch(e) {
        alert("Fehler: " + e.message);
    }
}

function processLoop() {
    if(!streaming) return;

    // 1. Bild holen
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    let src = cv.imread(canvas);
    
    // 2. Verarbeitung starten
    try {
        let result = findFeatures(src);
        
        if(result) {
            currentFramePoints = result;
            drawOverlay(result);
            updateStatus("Erkannt", "green");
            document.getElementById("btn-action").disabled = false;
            document.getElementById("btn-action").style.opacity = "1";
        } else {
            currentFramePoints = null;
            updateStatus("Suche...", "gray");
            document.getElementById("btn-action").disabled = true;
            document.getElementById("btn-action").style.opacity = "0.5";
        }
    } catch(e) {
        console.error(e);
    }
    
    src.delete();
    requestAnimationFrame(processLoop);
}

// Kern-Logik: Findet Papier und Würfel
function findFeatures(src) {
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    
    // A. Papier finden (Canny Edge)
    let blurred = new cv.Mat();
    cv.GaussianBlur(gray, blurred, new cv.Size(5,5), 0);
    cv.Canny(blurred, blurred, 50, 150);
    
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(blurred, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

    let paperPoints = null;
    let maxArea = (src.cols * src.rows) * 0.05; // Mindestens 5% des Bildes

    for(let i=0; i<contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        if(area > maxArea) {
            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
            
            if(approx.rows === 4 && cv.isContourConvex(approx)) {
                maxArea = area;
                // Daten extrahieren
                let pts = [];
                for(let j=0; j<4; j++) {
                    pts.push({ x: approx.data32S[j*2], y: approx.data32S[j*2+1] });
                }
                paperPoints = sortCorners(pts);
            }
            approx.delete();
        }
        cnt.delete();
    }
    
    // Cleanup A
    gray.delete(); blurred.delete(); contours.delete(); hierarchy.delete();

    if(!paperPoints) return null; // Kein Papier -> Abbruch

    // B. Würfel finden (Farbe)
    let hsv = new cv.Mat();
    cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
    
    let mask = new cv.Mat();
    // HSV Range für Gelb (Toleranz +/- 15)
    let low = new cv.Mat(src.rows, src.cols, src.type(), [Math.max(0, yellowHue-15), 100, 100, 0]);
    let high = new cv.Mat(src.rows, src.cols, src.type(), [Math.min(180, yellowHue+15), 255, 255, 255]);
    
    cv.inRange(hsv, low, high, mask);
    
    // Rauschen entfernen
    let kernel = cv.Mat.ones(5, 5, cv.CV_8U);
    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
    
    let contoursCube = new cv.MatVector();
    let hierarchyCube = new cv.Mat();
    cv.findContours(mask, contoursCube, hierarchyCube, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    
    let cubeCenter = null;
    let maxYellow = 0;
    
    for(let i=0; i<contoursCube.size(); i++) {
        let cnt = contoursCube.get(i);
        let area = cv.contourArea(cnt);
        if(area > 200 && area > maxYellow) {
            maxYellow = area;
            let M = cv.moments(cnt, false);
            if(M.m00 !== 0) {
                cubeCenter = { x: M.m10 / M.m00, y: M.m01 / M.m00 };
            }
        }
        cnt.delete();
    }

    // Cleanup B
    hsv.delete(); mask.delete(); low.delete(); high.delete(); kernel.delete(); 
    contoursCube.delete(); hierarchyCube.delete();

    if(cubeCenter) {
        // Rückgabe: Array mit 5 Punkten [TL, TR, BR, BL, CUBE]
        return [...paperPoints, cubeCenter];
    }
    
    return null;
}

function drawOverlay(pts) {
    // Papier Rahmen
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#00FF00";
    ctx.moveTo(pts[0].x, pts[0].y); // TL
    ctx.lineTo(pts[1].x, pts[1].y); // TR
    ctx.lineTo(pts[2].x, pts[2].y); // BR
    ctx.lineTo(pts[3].x, pts[3].y); // BL
    ctx.closePath();
    ctx.stroke();
    
    // Würfel Punkt
    let cube = pts[4];
    ctx.beginPath();
    ctx.fillStyle = "#FF0000";
    ctx.arc(cube.x, cube.y, 8, 0, 2*Math.PI);
    ctx.fill();
}

function captureFrame() {
    if(!currentFramePoints) return;
    
    // Wir speichern nur die Rohdaten (JS Objekte), keine OpenCV Mats!
    // Das verhindert Speicherlecks.
    capturedPoints.push(JSON.parse(JSON.stringify(currentFramePoints)));
    
    let count = capturedPoints.length;
    document.getElementById("count").innerText = count;
    
    // Flash Animation
    const flash = document.createElement("div");
    flash.className = "absolute inset-0 bg-white opacity-50 transition-opacity duration-200";
    document.body.appendChild(flash);
    setTimeout(() => flash.style.opacity = 0, 50);
    setTimeout(() => flash.remove(), 250);

    if(count >= MIN_IMGS) {
        document.getElementById("btn-calc").classList.remove("hidden");
        // Scroll nach unten, falls nötig
        document.querySelector(".panel").scrollTop = 1000; 
    }
}

function runCalibration() {
    // 1. UI Feedback sofort geben
    updateStatus("Rechne...", "blue");
    document.getElementById("btn-calc").disabled = true;
    document.getElementById("btn-calc").innerText = "Berechne...";
    
    // 2. Berechnung verzögern, damit UI rendern kann (sonst Freeze ohne Textänderung)
    setTimeout(() => {
        performCalculation();
    }, 100);
}

function performCalculation() {
    // Speicherverwaltung ist hier kritisch!
    let objPointsMatVector = new cv.MatVector();
    let imgPointsMatVector = new cv.MatVector();
    let matsToDelete = []; // Garbage Collection Helper

    try {
        // Für JEDES aufgenommene Bild müssen wir eine EIGENE 3D-Matrix erstellen
        // Wenn man dieselbe Matrix mehrfach pusht, stürzt OpenCV.js ab.
        capturedPoints.forEach(points => {
            
            // 3D Punkte Matrix (CV_32FC3)
            let objMat = cv.matFromArray(5, 1, cv.CV_32FC3, WORLD_COORDS);
            objPointsMatVector.push_back(objMat);
            matsToDelete.push(objMat);

            // 2D Bild Punkte Matrix (CV_32FC2)
            // Daten flachklopfen [x1,y1, x2,y2, ...]
            let flatPoints = [];
            points.forEach(p => { flatPoints.push(p.x); flatPoints.push(p.y); });
            
            let imgMat = cv.matFromArray(5, 1, cv.CV_32FC2, flatPoints);
            imgPointsMatVector.push_back(imgMat);
            matsToDelete.push(imgMat);
        });

        // Output Matrizen
        let cameraMatrix = new cv.Mat.eye(3, 3, cv.CV_64F);
        let distCoeffs = new cv.Mat.zeros(8, 1, cv.CV_64F);
        let rvecs = new cv.MatVector();
        let tvecs = new cv.MatVector();
        
        // Initial Guess (Hilft bei wenigen Punkten)
        cameraMatrix.data64F[0] = 1000; // fx
        cameraMatrix.data64F[4] = 1000; // fy
        cameraMatrix.data64F[2] = canvas.width / 2; // cx
        cameraMatrix.data64F[5] = canvas.height / 2; // cy

        // --- DIE MAGIE ---
        let rms = cv.calibrateCamera(
            objPointsMatVector,
            imgPointsMatVector,
            new cv.Size(canvas.width, canvas.height),
            cameraMatrix,
            distCoeffs,
            rvecs,
            tvecs,
            cv.CALIB_USE_INTRINSIC_GUESS
        );

        // Ergebnis anzeigen
        document.getElementById("rms-display").innerText = "RMS: " + rms.toFixed(2);
        
        let msg = `Erfolg!\nRMS Fehler: ${rms.toFixed(3)}\n\nKameramatrix:\n[${cameraMatrix.data64F[0].toFixed(0)}, 0, ${cameraMatrix.data64F[2].toFixed(0)}]\n[0, ${cameraMatrix.data64F[4].toFixed(0)}, ${cameraMatrix.data64F[5].toFixed(0)}]\n[0, 0, 1]`;
        alert(msg);
        
        updateStatus("Fertig", "green");
        
        // Cleanup Outputs
        cameraMatrix.delete(); distCoeffs.delete(); rvecs.delete(); tvecs.delete();

    } catch(e) {
        alert("Rechenfehler: " + e);
        console.error(e);
        updateStatus("Fehler", "red");
    } finally {
        // Aufräumen aller temporären Matrizen
        matsToDelete.forEach(m => m.delete());
        objPointsMatVector.delete();
        imgPointsMatVector.delete();
        
        document.getElementById("btn-calc").disabled = false;
        document.getElementById("btn-calc").innerText = "Neu Berechnen";
    }
}

function resetData() {
    capturedPoints = [];
    document.getElementById("count").innerText = "0";
    document.getElementById("btn-calc").classList.add("hidden");
    document.getElementById("rms-display").innerText = "RMS: --";
    updateStatus("Reset", "gray");
}

function sortCorners(pts) {
    // Sortiere nach Y
    pts.sort((a,b) => a.y - b.y);
    // Top 2 nach X
    let top = pts.slice(0,2).sort((a,b) => a.x - b.x);
    // Bottom 2 nach X
    let bottom = pts.slice(2,4).sort((a,b) => a.x - b.x);
    // Reihenfolge: TL, TR, BR, BL
    return [top[0], top[1], bottom[1], bottom[0]];
}
</script>
</body>
</html>