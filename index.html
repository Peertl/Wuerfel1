<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Scanner: A4 + Würfel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()"></script>
    <style>
        body { margin:0; background:#050505; color:white; overflow:hidden; font-family: sans-serif; }
        video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
        .panel { 
            position:absolute; bottom:20px; left:20px; right:20px; 
            background:rgba(20,20,20,0.9); padding:15px; border-radius:16px; 
            border: 1px solid rgba(255,255,255,0.1); z-index:10; max-width: 500px; margin: 0 auto;
        }
        .btn { 
            width:100%; padding:12px; border-radius:10px; border:none; font-weight:bold; margin-top:10px;
            background: linear-gradient(135deg, #FFD700, #ffb000); color:black;
        }
        .btn:disabled { opacity:0.3; filter:grayscale(1); }
    </style>
</head>
<body>

<video id="video" playsinline muted style="display:none"></video>
<canvas id="canvas"></canvas>

<div class="panel">
    <div class="flex justify-between items-center text-sm mb-2">
        <span class="font-bold text-yellow-400">Hybrid Kalibrierung</span>
        <span id="status">Lade OpenCV...</span>
    </div>
    
    <!-- Farb-Slider für Gelb-Feintuning (falls Licht schlecht ist) -->
    <div class="space-y-2 mb-2 bg-gray-800 p-2 rounded text-xs">
        <div class="flex justify-between">
            <span>Würfel Farbe (Hue)</span>
            <span id="hue-val">25</span>
        </div>
        <input type="range" min="10" max="50" value="25" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer" oninput="updateHue(this.value)">
    </div>

    <div class="flex justify-between text-xs text-gray-400 mb-2">
        <span>Gespeicherte Posen: <span id="count" class="text-white">0</span>/6</span>
        <span id="rms-display">--</span>
    </div>

    <button id="action-btn" class="btn" onclick="startCamera()" disabled>Kamera starten</button>
    <button id="reset-btn" class="btn bg-gray-700 text-white mt-2" style="background:#333; color:white;" onclick="resetData()">Reset</button>

    <div class="text-[10px] text-gray-500 mt-2 text-center leading-tight">
        A4 Blatt + Gelber Würfel (44mm) in der Mitte.<br>
        Grüner Rahmen = Blatt, Roter Punkt = Würfel.
    </div>
</div>

<script>
/** 
 * KONFIGURATION DER WELT
 */
const A4_W = 210;
const A4_H = 297;
const CUBE_H = 44; 

// Die 5 Referenzpunkte im 3D Raum (in mm)
// Blatt liegt bei Z=0. Würfel ragt auf Z=44 hoch.
const WORLD_POINTS = [
    0, 0, 0,                // TL (Papier)
    A4_W, 0, 0,             // TR (Papier)
    A4_W, A4_H, 0,          // BR (Papier)
    0, A4_H, 0,             // BL (Papier)
    A4_W/2, A4_H/2, -CUBE_H // Würfel Mitte Oben (Minus Z, da OpenCV Z-Achse nach vorne zeigt)
];

let video, canvas, ctx;
let streaming = false;
let capturedSets = []; // Speichert Sets von 5 Punkten (4x Papier, 1x Würfel)
let currentPoints = null; // Aktuell gefundene Punkte im Frame

// Gelb-Erkennung (HSV)
let yellowHue = 25; // Standardmitte für Gelb
let yellowRange = 15; // Toleranz

function updateHue(val) {
    yellowHue = parseInt(val);
    document.getElementById("hue-val").innerText = val;
}

function onOpenCvReady() {
    document.getElementById("status").innerText = "Bereit";
    document.getElementById("status").className = "text-green-400";
    document.getElementById("action-btn").disabled = false;
}

async function startCamera() {
    video = document.getElementById("video");
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d", { willReadFrequently: true });

    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } }
        });
        video.srcObject = stream;
        await video.play();
        
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        streaming = true;
        document.getElementById("action-btn").innerText = "Scan speichern";
        document.getElementById("action-btn").onclick = capturePose;
        
        requestAnimationFrame(processFrame);
    } catch(e) {
        alert("Kamera Fehler: " + e.message);
    }
}

function processFrame() {
    if(!streaming) return;

    // 1. Setup
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    let src = cv.imread(canvas);
    let dst = src.clone(); // Zum Zeichnen
    
    // 2. Suche A4 Blatt (Weißes Rechteck)
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
    cv.Canny(gray, gray, 50, 150);
    
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(gray, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

    let paperQuad = null;
    let maxArea = (canvas.width * canvas.height) * 0.10; // Mind 10% Bildfläche

    for(let i=0; i<contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        if(area > maxArea) {
            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
            
            if(approx.rows === 4 && cv.isContourConvex(approx)) {
                maxArea = area;
                if(paperQuad) paperQuad.delete();
                paperQuad = approx.clone();
            }
            approx.delete();
        }
        cnt.delete();
    }

    // 3. Suche Gelben Würfel
    let hsv = new cv.Mat();
    cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB); // OpenCV js lädt oft als RGBA, Umwandlung nötig
    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
    
    let mask = new cv.Mat();
    let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [yellowHue - yellowRange, 100, 100, 0]);
    let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [yellowHue + yellowRange, 255, 255, 255]);
    cv.inRange(hsv, low, high, mask);
    
    // Morphologische Ops um Rauschen zu entfernen
    let kernel = cv.Mat.ones(5, 5, cv.CV_8U);
    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
    
    let cubeCenter = null;
    let contoursCube = new cv.MatVector();
    cv.findContours(mask, contoursCube, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    
    // Nimm das größte gelbe Objekt
    let maxYellowArea = 0;
    for(let i=0; i<contoursCube.size(); i++) {
        let cnt = contoursCube.get(i);
        let area = cv.contourArea(cnt);
        if(area > 500 && area > maxYellowArea) { // Mindestgröße
            maxYellowArea = area;
            let moments = cv.moments(cnt, false);
            cubeCenter = {
                x: moments.m10 / moments.m00,
                y: moments.m01 / moments.m00
            };
        }
        cnt.delete();
    }

    // 4. Validierung und Zeichnen
    currentPoints = null;
    
    if(paperQuad && cubeCenter) {
        // Papier Ecken sortieren
        let pts = [];
        for(let i=0; i<4; i++) pts.push({x: paperQuad.data32S[i*2], y: paperQuad.data32S[i*2+1]});
        let sortedPaper = sortCorners(pts);
        
        // Prüfen ob Würfel innerhalb des Papiers liegt (einfacher Bounding Box Check)
        // Hier vereinfacht: Wir nehmen an, wenn beides da ist, passt es.
        
        currentPoints = [...sortedPaper, cubeCenter];
        
        // Visualisierung
        // Papier-Rahmen
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#00FF00";
        ctx.moveTo(sortedPaper[0].x, sortedPaper[0].y);
        sortedPaper.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.stroke();
        
        // Würfel-Punkt
        ctx.beginPath();
        ctx.fillStyle = "#FF0000";
        ctx.arc(cubeCenter.x, cubeCenter.y, 10, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillStyle = "white";
        ctx.font = "12px monospace";
        ctx.fillText("WÜRFEL (Z=44)", cubeCenter.x + 15, cubeCenter.y);
        
        document.getElementById("status").innerText = "Tracking stabil";
        document.getElementById("status").className = "text-green-400";
        document.getElementById("action-btn").disabled = false;
        document.getElementById("action-btn").classList.remove("opacity-50");
    } else {
        document.getElementById("status").innerText = "Suche A4 + Würfel...";
        document.getElementById("status").className = "text-yellow-500";
        document.getElementById("action-btn").disabled = true;
        document.getElementById("action-btn").classList.add("opacity-50");
    }

    // Cleanup
    src.delete(); dst.delete(); gray.delete(); hsv.delete(); mask.delete(); 
    contours.delete(); contoursCube.delete(); hierarchy.delete(); low.delete(); high.delete(); kernel.delete();
    if(paperQuad) paperQuad.delete();

    requestAnimationFrame(processFrame);
}

function capturePose() {
    if(!currentPoints) return;
    
    capturedSets.push(currentPoints);
    document.getElementById("count").innerText = capturedSets.length;
    
    // Visuelles Feedback
    canvas.style.opacity = 0.5;
    setTimeout(() => canvas.style.opacity = 1, 100);
    
    if(capturedSets.length >= 6) {
        calibrate();
    }
}

function calibrate() {
    document.getElementById("action-btn").innerText = "Berechne...";
    
    let objPoints = new cv.MatVector();
    let imgPoints = new cv.MatVector();
    
    // 3D Referenzpunkte erstellen (für alle Frames gleich)
    let obj = cv.matFromArray(5, 1, cv.CV_32FC3, WORLD_POINTS);
    
    // Gesammelte Daten konvertieren
    capturedSets.forEach(points => {
        let img = new cv.Mat(5, 1, cv.CV_32FC2);
        for(let i=0; i<5; i++) {
            img.data32F[i*2] = points[i].x;
            img.data32F[i*2+1] = points[i].y;
        }
        
        objPoints.push_back(obj);
        imgPoints.push_back(img);
    });
    
    let camMat = new cv.Mat.eye(3, 3, cv.CV_64F);
    let distCoeffs = new cv.Mat.zeros(8, 1, cv.CV_64F);
    let rvecs = new cv.MatVector();
    let tvecs = new cv.MatVector();
    
    try {
        // Initial Guess flags sind wichtig bei wenigen Punkten
        let flags = cv.CALIB_USE_INTRINSIC_GUESS;
        // Grobe Schätzung: Fokus liegt in Bildmitte
        camMat.data64F[0] = 1000; camMat.data64F[4] = 1000;
        camMat.data64F[2] = canvas.width/2; camMat.data64F[5] = canvas.height/2;

        let rms = cv.calibrateCamera(objPoints, imgPoints, new cv.Size(canvas.width, canvas.height), camMat, distCoeffs, rvecs, tvecs, flags);
        
        document.getElementById("rms-display").innerText = "RMS: " + rms.toFixed(2);
        alert(`Kalibrierung erfolgreich!\nRMS Fehler: ${rms.toFixed(2)}\nDie 3D-Information des Würfels hat geholfen!`);
        
        console.log("Camera Matrix:", camMat.data64F);
        
    } catch(e) {
        alert("Fehler bei Berechnung: " + e);
    }
    
    // Reset UI
    document.getElementById("action-btn").innerText = "Scan speichern";
    obj.delete(); objPoints.delete(); imgPoints.delete();
    camMat.delete(); distCoeffs.delete(); rvecs.delete(); tvecs.delete();
}

function resetData() {
    capturedSets = [];
    document.getElementById("count").innerText = "0";
    document.getElementById("rms-display").innerText = "--";
}

// Hilfsfunktion: Sortiere Ecken (TL, TR, BR, BL)
function sortCorners(pts) {
    pts.sort((a,b) => a.y - b.y);
    let top = pts.slice(0,2).sort((a,b) => a.x - b.x);
    let bottom = pts.slice(2,4).sort((a,b) => b.x - a.x); // Hier trickreich: b-a damit wir BR zuerst haben? Nein.
    // Standard OpenCV: TL, TR, BR, BL.
    bottom.sort((a,b) => a.x - b.x); // Jetzt ist bottom[0] = BL, bottom[1] = BR
    return [ top[0], top[1], bottom[1], bottom[0] ];
}
</script>
</body>
</html>